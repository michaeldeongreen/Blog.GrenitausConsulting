<a href="assets/images/grenitaus-consulting-logo.png"><img class="img-responsive" src="assets/images/grenitaus-consulting-logo.png" alt="Grenitaus Consulting"></a>
<br><br>

Lately, I have been working with a lot of legacy code.  One of the hallmarks of legacy code is that it often times contains mission critical code, it isn't Unit Testable and because of the aforementioned reasons, developers don't enjoy making changes to it.

<br><br>

One type of legacy code that I have come across quite frequently is the so called "God" class.  A God class is a class that literally does everything.  The God class that I recently performed some slight re-factoring on was responsible for loading its data from the database, encrypting and decrypting its data, performing tons of business logic, contained very generic code like converting a int to string and saving its own data.  Below is a general example of the God class: 

<br><br>

<pre><code class="language-csharp">
    public class LoanApplication
    {
		public SomeObject1 SomeObject1 { get; set; }
		public SomeObject2 SomeObject2 { get; set; }
		public int ApplicationId { get; set; }
		//....
		
		public void BusinessLogicMethod1()
		{
			//....
		}
		
		public void BusinessLogicMethod2()
		{
			//....
		}		
		
		public void BusinessLogicMethod2()
		{
			//....
		}		
		
		public void Encrypt()
		{
			//....
		}		

		public void Decrypt()
		{
			//....
		}				
		
		public LoanApplication Load()
		{
            var dataSet = Database.LoanApplication_Select.ExecDS(ApplicationID);

            if (dataSet.Tables.Count == 0 || dataSet.Tables[0].Rows.Count == 0) return this;

            _loanApplicationLoadService.Load(this, dataSet);

            return this;		
		}
	}
</code></pre>